% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R, R/feature_groups.R,
%   R/feature_groups-set.R, R/compounds.R, R/feature_groups-screening.R,
%   R/feature_groups-screening-set.R, R/compounds-set.R, R/compounds-sirius.R,
%   R/formulas-set.R, R/formulas-sirius.R, R/utils-exported.R
\name{pred-quant}
\alias{pred-quant}
\alias{calculateConcs,featureGroups-method}
\alias{calculateConcs}
\alias{calculateConcs,featureGroupsSet-method}
\alias{predictRespFactors,compounds-method}
\alias{predictRespFactors,featureGroupsScreening-method}
\alias{calculateConcs,featureGroupsScreening-method}
\alias{predictRespFactors,featureGroupsScreeningSet-method}
\alias{calculateConcs,featureGroupsScreeningSet-method}
\alias{predictRespFactors,compoundsSet-method}
\alias{predictRespFactors,compoundsSIRIUS-method}
\alias{predictRespFactors,formulasSet-method}
\alias{predictRespFactors,formulasSIRIUS-method}
\alias{getQuantCalibFromScreening}
\title{Functionality to predict quantitative data}
\usage{
\S4method{calculateConcs}{featureGroups}(fGroups, featureAnn, areas = FALSE)

\S4method{calculateConcs}{featureGroupsSet}(fGroups, featureAnn, areas = FALSE)

\S4method{predictRespFactors}{compounds}(
  obj,
  fGroups,
  calibrants,
  eluent,
  organicModifier,
  pHAq,
  concUnit = "ugL",
  calibConcUnit = concUnit,
  updateScore = FALSE,
  scoreWeight = 1,
  parallel = TRUE
)

\S4method{predictRespFactors}{featureGroupsScreening}(
  obj,
  calibrants,
  eluent,
  organicModifier,
  pHAq,
  concUnit = "ugL",
  calibConcUnit = concUnit
)

\S4method{calculateConcs}{featureGroupsScreening}(fGroups, featureAnn = NULL, areas = FALSE)

\S4method{predictRespFactors}{featureGroupsScreeningSet}(obj, calibrants, ...)

\S4method{calculateConcs}{featureGroupsScreeningSet}(fGroups, featureAnn = NULL, areas = FALSE)

\S4method{predictRespFactors}{compoundsSet}(obj, fGroups, calibrants, ...)

\S4method{predictRespFactors}{compoundsSIRIUS}(
  obj,
  fGroups,
  calibrants,
  eluent,
  organicModifier,
  pHAq,
  concUnit = "ugL",
  calibConcUnit = concUnit,
  type = "FP"
)

\S4method{predictRespFactors}{formulasSet}(obj, fGroups, calibrants, ...)

\S4method{predictRespFactors}{formulasSIRIUS}(
  obj,
  fGroups,
  calibrants,
  eluent,
  organicModifier,
  pHAq,
  concUnit = "ugL",
  calibConcUnit = concUnit
)

getQuantCalibFromScreening(fGroups, concs, areas = FALSE, average = FALSE)
}
\arguments{
\item{fGroups}{For \code{predictRespFactors} methods for feature annotations: The \code{\link{featureGroups}} object
  for which the annotations were performed.

  For \code{calculateConcs}: The \code{\link{featureGroups}} object for which concentrations should be calculated.

  For \code{getQuantCalibFromScreening}: A feature groups object screened for the calibrants with
  \code{\link{screenSuspects}}.}

\item{featureAnn}{A \code{\link{featureAnnotations}} object (\emph{e.g.} \code{\link{formulasSIRIUS}} or
\code{\link{compounds}}) which contains response factors. Optional if \code{calculateConcs} is called on suspect
screening results (\emph{i.e.} \code{\link{featureGroupsScreening}} method).}

\item{areas}{Set to \code{TRUE} to use peak areas instead of peak heights. Note: for \code{calculateConcs} this
should follow what is in the \code{calibrants} table.}

\item{obj}{The workflow object for which predictions should be performed, \emph{e.g.} feature groups with screening
results (\code{\link{featureGroupsScreening}}) or compound annotations (\code{\link{compounds}}).}

\item{calibrants}{A \code{data.frame} with calibrants, see the \verb{Calibration} section below.

  \setsWF Should be a \code{list} with the calibrants for each set.}

\item{eluent}{A \code{data.frame} that describes the LC gradient program. Should have a column \code{time} with the
retention time in seconds and a column \code{B} with the corresponding percentage of the organic modifier
(\samp{0-100}).}

\item{organicModifier}{The organic modifier of the mobile phase: either \code{"MeOH"} (methanol) or \code{"MeCN"}
(acetonitrile).}

\item{pHAq}{The \acronym{pH} of the aqueous part of the mobile phase.}

\item{concUnit}{The concentration unit for calculated concentrations. Can be molar based (\code{"nM"}, \code{"uM"},
\code{"mM"}, \code{"M"}) or mass based (\code{"ngL"}, \code{"ugL"}, \code{"mgL"}, \code{"gL"}). Furthermore, can be
prefixed with \code{"log "} for logarithmic concentrations (\emph{e.g.} \code{"log mM"}).}

\item{calibConcUnit}{The concentration unit used in the calibrants table. For possible values see the \code{concUnit}
argument.}

\item{updateScore, scoreWeight}{If \code{updateScore=TRUE} then the annotation \code{score} column is updated
by adding normalized values of the response factor (weighted by \option{scoreWeight}). Currently, this
\strong{only} makes sense for annotations performed with \command{MetFrag}!}

\item{parallel}{If set to \code{TRUE} then code is executed in parallel through the \CRANpkg{futures} package. Please
see the parallelization section in the handbook for more details.}

\item{\dots}{\setsWF Further arguments passed to the non-sets workflow method.}

\item{type}{Which types of predictions should be performed: should be \code{"FP"} (\command{SIRIUS+CSI:FingerID}
fingerprints), \code{"SMILES"} or \code{"both"}. Only relevant for \code{\link{compoundsSIRIUS}} method.}

\item{concs}{A \code{data.frame} with concentration data. See the \verb{Calibration} section below.}

\item{average}{Set to \code{TRUE} to average intensity values within replicate groups.}
}
\value{
\code{predictRespFactors} returns an object amended with response factors (\code{RF_SMILES}/\code{LRF_SIRFP}
  columns).

  \code{calculateConcs} returns a \code{\link{featureGroups}} based object amended with concentrations for each
  feature group (accessed with the \code{\link{concentrations}} method).
}
\description{
Functions to predict response factors and feature concentrations from \acronym{SMILES} and/or
\command{SIRIUS+CSI:FingerID} fingerprints using the \pkg{MS2Quant} package.
}
\details{
The \href{https://github.com/kruvelab/MS2Quant}{MS2Quant} \R package predicts concentrations from \acronym{SMILES}
and/or MS/MS fingerprints obtained with \command{SIRIUS+CSI:FingerID}. The \code{predictRespFactors} method functions
interface with this package to calculate response factors, which can then be used to calculate feature concentrations
with the \code{calculateConcs} method function.
}
\note{
The \CRANpkg{rcdk} package and \href{https://github.com/openbabel/openbabel}{OpenBabel} tool are used
  internally to calculate molecular weights. Please make sure that \command{OpenBabel} is installed.

\pkg{MS2Quant} currently \emph{only} supports \samp{M+H} and \samp{M+} adducts when performing predictions with
  \command{SIRIUS:FingerID} fingerprints. Predictions for candidates with other adducts, including \samp{M-H]}, are
  skipped with a warning.
}
\section{Calibration}{
 The \pkg{MS2Quant} package requires calibration to convert predicted ionization efficiencies to
  instrument/method specific response factors. The calibration data should be specified with the \code{calibrants}
  argument to \code{predictRespFactors}. This should be a \code{data.frame} with intensity observations at different
  concentrations for a set of calibrants. Each row specifies one intensity observation at one concentration. The
  table should have the following columns:

  \itemize{

  \item \code{name} The name of the calibrant. Can be freely chosen.

  \item \code{SMILES} The \acronym{SMILES} of the calibrant.

  \item \code{rt} The retention time of the calibrant (in seconds).

  \item \code{intensity} The peak intensity (or area, see the \code{areas} argument) of the calibrant.

  \item \code{conc} The concentration of the calibrant (see the \code{calibConcUnit} argument for specifying the unit).

  }

  It is recommended to include multiple calibrants (\emph{e.g.} \samp{>=10}) at multiple concentrations (\emph{e.g.}
  \samp{>=5}). The latter is achieved by adding multiple rows for the same calibrant (keeping the
  \code{name}/\code{SMILES}/\code{rt} columns constant). It is also possible to follow the column naming used by
  \pkg{MS2Quant} (however retention times should still be in seconds!). For more details and tips see
  \url{https://github.com/kruvelab/MS2Quant}.

  The \code{getQuantCalibFromScreening} function can be used to automatically generate a calibrants table from a
  feature groups object with suspect screening results. Here, the idea is to perform a screening with
  \code{\link{screenSuspects}} with a suspect list that contain the calibrants, which is then used to construct the
  calibrant table. It is highly recommended to add retention times for the calibrants in the suspect list to ensure
  the calibrant is assigned to the correct feature. Furthermore, it is possible to simply add the calibrants to the
  'regular' suspect list in case a suspect screening was already part of the workflow. The
  \code{getQuantCalibFromScreening} function still requires you to specify concentration data, which is achieved via
  the \code{concs} argument. This should be a \code{data.frame} with a column \code{name} corresponding to the
  calibrant name (\emph{i.e.} same as used by \code{screenSuspects} above) and columns with concentration data. The
  latter columns specify the concentrations of a calibrant in different replicate groups (as defined in the
  \link[=analysis-information]{analysis information}). The concentration columns should be named after the
  corresponding replicate group. Only those replicate groups that should be used for calibration need to be included.
  Furthermore, \code{NA} values can be used if a replicate group should be ignored for a specific calibrant.
}

\section{Predicting response factors}{
 The response factors are predicted with the \code{predictRespFactors} generic functions,
  which accepts the following input:

\itemize{

\item \link[=suspect-screening]{Suspect screening results}. The \acronym{SMILES} data is used to predict
response factors for suspect hits.

\item Formula annotation data obtained with \code{"sirius"} algorithm (\code{\link{generateFormulasSIRIUS}}). The
predictions are performed for each formula candidate using \command{SIRIUS+CSI:FingerID} fingerprints. For this
reason, the \code{getFingerprint} argument must be set to \code{TRUE} when generating the formula data.

\item Compound annotation data obtained with the \code{"sirius"} algorithm (\code{\link{generateCompoundsSIRIUS}}).
The predictions are performed for each annotation candidate using its \acronym{SMILES} and/or
\command{SIRIUS+CSI:FingerID} fingerprints. The predictions are performed on a per formula basis, hence,
response factors for isomers will be equal.

\item Compound annotation data obtained with algorithms other than \code{"sirius"}. The response factors are predicted
from \acronym{SMILES} data.

}

  When \acronym{SMILES} data is used then predictions of response factors are generally more accurate. However,
  calculations with \command{SIRIUS+CSI:FingerID} fingerprints are faster and only require the formula and MS/MS
  spectrum, \emph{i.e.} not the full structure. Hence, calculations with \acronym{SMILES} are mostly useful in
  suspect screening workflows, or with high confidence compound annotation data, whereas MS/MS fingerprints are
  suitable with unknowns.

  For annotation data the calculations are performed for \emph{all} candidates. This can especially lead to long
  running calculations when \acronym{SMILES} data is used. Hence, it is \strong{strongly} recommended to first
  prioritize the annotation results, \emph{e.g.} with the \code{topMost} argument to the
  \link[=filter,featureAnnotations-method]{filter method}.

  When response factors are predicted from \command{SIRIUS+CSI:FingerID} fingerprints then only formula and MS/MS
  spectra are used, even if compound annotations are used for input. The major difference is that with formula
  annotation input \emph{all} formula candidates for which a fingerprint could be generated are considered, whereas
  with compound annotations only candidate formulae are considered for which also a structure could be assigned.
  Hence, the formula annotation input could be more comprehensive, whereas predictions from structure annotations
  could lead to more representative results as only formulae are considered for which at least one structure could be
  assigned.
}

\section{Assigning concentrations}{
 The \code{calculateConcs} generic function is used to assign concentrations for each
  feature using the response factors discussed in the previous section. The function takes response factors from suspect
  screening results and/or feature annotation data. If multiple response factors were predicted for the same feature
  group, for instance when multiple annotation candidates or suspect hits for this feature group are present, then a
  concentrations is assigned for all response factors. These values can later be easily aggregated with \emph{e.g.} the
  \link[=as.data.table,featureGroups-method]{as.data.table} function.
}

\references{
\insertRef{OBoyle2011}{patRoon} \cr \cr \addCitations{rcdk}

\insertRef{Sepman2023}{patRoon}
}
\seealso{
\link[=pred-tox]{Toxicity prediction}
}
